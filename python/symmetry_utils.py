import numpy as np
import itertools

def validatedSymmetryAxes(dim, symmetry_axes_mask):
    if symmetry_axes_mask is None: symmetry_axes_mask = np.zeros(dim, dtype=bool)
    if (symmetry_axes_mask.dtype != bool or symmetry_axes_mask.size != dim): raise Exception('Illegal symmetry_axes_mask type')
    return symmetry_axes_mask

def numReflectedCopies(symmetry_axes_mask):
    """
    The number of copies of a base cell grid generated by reflecting across its
    symmetry planes (as specified by `symmetry_axes_mask`).
    """
    return 2 ** symmetry_axes_mask.sum()

def reflectBaseCellToFull(rho_basecell, symmetry_axes_mask):
    in_shape = rho_basecell.shape
    full_shape = np.array(rho_basecell.shape)
    full_shape[symmetry_axes_mask] *= 2
    rho_full = np.empty(full_shape)
    # Generate each reflected copy of the base cell
    for reflect in itertools.product(*(range(s + 1) for s in symmetry_axes_mask)):
        input_slice  = tuple([slice(None, None, -1) if r else slice(None, None) for r in reflect])
        output_slice = tuple([slice(r * in_shape[d], (r + 1) * in_shape[d]) for d, r in enumerate(reflect)])
        rho_full[output_slice] = rho_basecell[input_slice]
    return rho_full
        
def extractBaseCell(rho_full, symmetry_axes_mask):
    full_shape = rho_full.shape
    out_shape = np.array(rho_full.shape)
    out_shape[symmetry_axes_mask] //= 2
    return rho_full[tuple([slice(0, s) for s in out_shape])]

def sumToBaseCell(rho_full, symmetry_axes_mask):
    full_shape = rho_full.shape
    out_shape = np.array(rho_full.shape)
    out_shape[symmetry_axes_mask] //= 2
    result = np.zeros(out_shape)
    # Generate each reflected copy of the base cell
    for reflect in itertools.product(*(range(s + 1) for s in symmetry_axes_mask)):
        output_slice  = tuple([slice(None, None, -1) if r else slice(None, None) for r in reflect])
        input_slice = tuple([slice(r * in_shape[d], (r + 1) * in_shape[d]) for d, r in enumerate(reflect)])
        result[output_slice] += rho_basecell[input_slice]
    return result

def averageToBaseCell(rho_full, symmetry_axes_mask):
    return sumToBaseCell(rho_full, symmetry_axes_mask) * (2 ** np.sum(symmetry_axes_mask))
